<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2020%2F09%2F25%2Fmysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[mysqlmysql安装后默认有一个root用户，可以先使用root用于登陆 mysql -u 用户名 -p mysql -u root -p12345678910111213141516171819202122简单使用：显示数据库show databases;自带数据库information_schema mysql本身架构相关数据mysql 用户权限相关数据创建数据库utf-8：create database 数据库名 default charset utf8 collate utf8_general_ci;gbk：create database 数据库名 default charset gbk collate utf8_chinese_ci;使用数据库use 数据库名;查看当前正在使用的数据库select database();显示当前数据库中的所有表show tables; 1234567891011121314151617181920用户管理： 注意：需要使用root用户 创建用户 create user &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos;; 示例： create user &apos;alex&apos;@&apos;10.0.0.1&apos; identified by &apos;alex1999&apos;; 允许10.0.0.1使用alex用户登录 create user &apos;alex&apos;@&apos;10.0.0.%&apos; identified by &apos;alex1999&apos;; 允许10.0.0.*网段使用alex用户登录 create user &apos;alex&apos;@&apos;%&apos; identified by &apos;sunck1999&apos;; 查看： use mysql; select user,host from user;删除用户： dorp user &apos;用户名&apos;@&apos;IP地址&apos;;修改用户： rename user &apos;用户名&apos;@&apos;IP地址&apos; to &apos;新用户名&apos;@&apos;IP地址&apos;;修改用户密码： set password for &apos;用户名&apos;@&apos;IP地址&apos; = password(&apos;新密码&apos;); 1234567891011121314151617181920212223242526授权管理：需要root用户查看权限： show grants for &apos;用户名&apos;@&apos;IP地址&apos;;授权： 格式：grant 权限 on 数据库.表 to &apos;用户名&apos;@&apos;IP地址&apos;;示例： 只能对xxx数据库下的t1表进行查看和插入操作 grant select,insert on xxx.t1 to &apos;sunck&apos;@&apos;%&apos;; 只能对xxx数据库下的所有表进行查看和插入操作 grant select,insert on xxx.* to &apos;sunck&apos;@&apos;%&apos;; 添加对xxx数据库下所有表，添加grant以外的所有权限 grant all privileges on xxx.* to &apos;sunck&apos;@&apos;%&apos;;权限说明：详情见《权限说明》取消授权： revoke 权限 on 数据库.表 from &apos;用户名&apos;@&apos;IP地址&apos;;将数据读取到内存，立即生效 flush privileges修改mysql的配置sudo vim /etc/mysql/mysql.conf.d/mysqld.cnfbind-address = 127.0.0.1 ---&gt;bind-address = 0.0.0.0 权限名 权限说明 all privileges 除grant外的所有权限 select 仅查权限 select,insert 查和插入权限 usage 无访问权限 alter 使用alter table alter routine 使用alter procedure和drop procedure create 使用create table create routine 使用create procedure create temporary tables 使用create temporary tables create user 使用create user、drop user、rename user和revoke all privileges create view 使用create view delete 使用delete drop 使用drop table execute 使用call和存储过程 file 使用select into outfile 和 load data infile grant option 使用grant 和 revoke index 使用index insert 使用insert lock tables 使用lock table process 使用show full processlist show databases 使用show databases show view 使用show view update 使用update reload 使用flush shutdown 使用mysqladmin shutdown(关闭MySQL) super 使用change master、kill、logs、purge、master和set global。还允许mysqladmin调试登陆 replication client 服务器位置的访问 replication slave 由复制从属使用 1234567891011121314151617181920212223242526272829字段约束：1、primary key 主键 作用：唯一约束标识数据库表中的每条记录 注意： 主键必须包含唯一的值 主键列不能包含null值 每个表都应该有一个主键，并且每个表只能拥有一个主键2、not null 非空 作用：约束强制列不能接受null值 注意：约束强制字段始终包含值，所以如过不想字段添加值，就无法插入和更新数据3、null 空 作用：允许为空4、auto_increment 自增长 作用：自增长 注意：对于自增长列，必须是索引(含主键)5、default 默认值 作用：用于向列中插入默认值6、unique 唯一值 作用：约束唯一标识数据库中表的每条数据 与primary key的区别： a、两者均为列或列集合提供了唯一性的保证 b、pk拥有自动定义的unique约束 c、每个表可以有多个unique约束，但是每个表只能有一个pk约束 使用：unique 唯一索引名称 (列名1[,……])7、foreign key 外键 说明：一个表中fK指向另一个表中的pk 作用： a、用于用于预防破坏表之间的连接的动作 b、也能防止非法数据插入外键列，因为它必须是它所指向的那个表中的值之一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162三、插入数据(增)1、全列插入 insert into 表名 values(值1,值2,……); 注意：主键是自增长，但是在全列插入式需要占位，插入成功后以实际值为准 insert into student values(0, 18, &apos;sunck&apos;); insert into student values(0, 50, &apos;刘德华&apos;); insert into student values(0, 40, &apos;刀郎&apos;);2、缺省插入 inset into 表名(列1,列2,……) values(值1,值2,……);3、同时插入多条数据 insert into 表名 values(值1,值2,……),(值1,值2,……),……; insert into 表名(列1,列2,……) values(值1,值2,……),(值1,值2,……),……;四、查看数据 select * from 表名; 说明： 1、from关键字后面写的表名，表示数据来源于这张表 2、select后面写表中的列名，如果是*，表示结果中显示表中所有的列 3、如果要查询多个列，列之间使用逗号分隔 五、删除表 drop table 表名;六、查看表结构 desc 表名 七、查看建表语句 show create table 表名; 横着看 show create table 表名 \G; 竖着看八、重命名表名 rename table 原表名 to 新表名;九、清空表数据 delete from 表名; truncate table 表名; 十、修改表 添加列 alter table 表名 add 列名 类型; 删除列 alter table 表名 drop column 列名; 修改列 alter table 表名 modify column 列名 类型;--类型 alter table 表名 change 原列名 新列名 类型;--列名,类型 添加主键 alter table 表名 add primary key(列名); 删除主键 alter table 表名 drop primary key; #列名后的类型会修改列名的类型 alter table 表名 modify 列名 int,drop primary key; 添加外键 alter table 从表 add constraint 外键名称 foreign key 从表(外键字段) references 主表(主表字段); 外键名称：fk_从表_主表 删除外键 alter table 表名 drop foreign key 外键名称 修改默认值 alter table 表名 alter 列名 set default 100; 删除默认值 alter table 表名 alter 列名 drop default;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo更换设备部署环境]]></title>
    <url>%2F2019%2F09%2F20%2Fhexo%E6%9B%B4%E6%8D%A2%E8%AE%BE%E5%A4%87%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、多设备同步 Github新建一个分支–hexo使用git指令将带hexo配置的Github工程文件上传到新建的分支上。12345678910111213在本地博客根目录下使用git指令上传项目到Github:// git初始化git init// 添加仓库地址git remote add origin https://github.com/用户名/仓库名.git// 新建分支并切换到新建的分支git checkout -b 分支名// 添加所有本地文件到gitgit add .// git提交git commit -m &quot;&quot;// 文件推送到hexo分支git push origin hexo 二、前提条件 安装git 安装node.js hexo个人博客 123npm install hexo -gnpm installnpm --save install hexo-deployer-git 设置Git的user name 和email 12git config --global user.name 名字git config --global user.email 邮箱 输入如下指令，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Ericam.ssh）。 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 打开id_rsa.pub文件复制全部内容。进入github账户的setting界面，进入SSH and GPG Keys目录，删除原来的SSH，新建SSH 三、坑点 主题文件夹上传不到github上 主题文件夹是空的而自己本地的主题文件夹是有文件的 探索大家可能想到是因为.gitignore里面忽略了这两个文件夹下的所有文件，但是经过自己的检查，发现并不是这儿的问题真正的解决办法经过多番探索，终于找到了症结，先来说如何解决 凡是通过git clone从github上拉取的代码，删除除了项目根目录以外的任何位置的 .git文件夹，.gitignore (或者编辑这个文件夹，删除那些你想上传但是被忽略的文件或文件夹) 和 .github 文件夹操作完成之后，用SourceTree还是看不到需要上传的主题文件在“未暂存文件”一栏中，不要失望接着往下看还要删除掉 SourceTree 中的 主题 子模块 ，如下图：删除时，一定要勾选 “强制删除” ，要不然会删除不掉，而且SourceTree报错 出现此问题的原因主要根源是每次我们下载主题时，都会用git命令clone源代码，例如像这样： 1$ git clone --branch v5.1.2 https://github.com/xxxx/xxxxx themes/next 最终导致自己的主题文件夹下多了个.git文件夹，会被认为是另一个资源库，从属于自己的项目之下，在SourceTree中显示成“子模块”，而这些项目需要的主题文件不会被push到自己的github仓库中。 四、git clone git@github.com:xxxx/xxxxx执行hexo s的时候报error, Cannot find module ‘./db.json’解决方法 12copy别人的 \node_modules\mime-db\db.json在别的目录下，执行npm install mime-db，然后把生成的db.json拷贝过去]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django REST framework的认证方式及自定义认证]]></title>
    <url>%2F2019%2F09%2F18%2FDjango%20REST%20framework%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[源码剖析Django REST framework的认证方式及自定义认证源码剖析Django REST framework的认证方式由Django的CBV模式流程，可以知道在url匹配完成后，会执行自定义的类中的as_view方法。如果自定义的类中没有定义as_view方法，根据面向对象中类的继承可以知道，则会执行其父类View中的as_view方法 在Django的View的as_view方法中，又会调用dispatch方法。 现在来看看Django restframework的认证流程 Django restframework是基于Django的框架，所以基于CBV的模式也会执行自定义的类中的as_view方法 先新建一个项目，配置url 12345678from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^user/', views.UserView.as_view()),] views.py文件内容 123456789101112from django.shortcuts import render,HttpResponsefrom rest_framework.views import APIViewclass UserView(APIView): def get(self,request,*args,**kwargs): print(request.__dict__) print(request.user) return HttpResponse("UserView GET") def post(self,request,*args,**kwargs): return HttpResponse("UserView POST") 启动项目，用浏览器向http://127.0.0.1:8000/user/发送get请求 可以知道请求发送成功。现在来看看源码流程，由于UserView继承APIView，查看APIView中的as_view方法 1234567891011121314151617class APIView(View): ... @classmethod def as_view(cls, **initkwargs): if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet): def force_evaluation(): raise RuntimeError( 'Do not evaluate the `.queryset` attribute directly, ' 'as the result will be cached and reused between requests. ' 'Use `.all()` or call `.get_queryset()` instead.' ) cls.queryset._fetch_all = force_evaluation view = super(APIView, cls).as_view(**initkwargs) view.cls = cls view.initkwargs = initkwargs return csrf_exempt(view) 通过super来执行APIView的父类Django的View中的as_view方法。上一篇文章源码解析Django CBV的本质中已经知道，View类的as_view方法会调用dispatch方法。 View类的as_view方法源码如下所示 1234567891011121314class View(object): ... @classonlymethod def as_view(cls, **initkwargs): ... def view(request, *args, **kwargs): self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs return self.dispatch(request, *args, **kwargs) ... as_view方法中的self实际上指的是自定义的UserView这个类，上面的代码会执行UserView类中dispatch方法。 由于UserView类中并没有定义dispatch方法，而UserView类继承自Django restframework的APIView类，所以会执行APIView类中的dispatch方法 12345678910111213141516171819202122def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response 可以看到，先执行initialize_request方法处理浏览器发送的request请求。 来看看initialize_request方法的源码 12345678910111213def initialize_request(self, request, *args, **kwargs): """ Returns the initial request object. """ parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) 在initialize_request方法里，把浏览器发送的request和restframework的处理器，认证，选择器等对象列表作为参数实例化Request类中得到新的request对象并返回，其中跟认证相关的对象就是authenticators。 12345def get_authenticators(self): """ Instantiates and returns the list of authenticators that this view can use. """ return [auth() for auth in self.authentication_classes] get_authenticators方法通过列表生成式得到一个列表，列表中包含认证类实例化后的对象 在这里，authentication_classes来自于api_settings的配置 1authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 通过查看api_settings的源码可以知道，可以在项目的settings.py文件中进行认证相关的配置 123456api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)def reload_api_settings(*args, **kwargs): setting = kwargs['setting'] if setting == 'REST_FRAMEWORK': api_settings.reload() Django restframework通过initialize_request方法对原始的request进行一些封装后实例化得到新的request对象 然后执行initial方法来处理新得到的request对象，再来看看initial方法中又执行了哪些操作 1234567891011def initial(self, request, *args, **kwargs): self.format_kwarg = self.get_format_suffix(**kwargs) neg = self.perform_content_negotiation(request) request.accepted_renderer, request.accepted_media_type = neg version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) 由上面的源码可以知道，在initial方法中，执行perform_authentication来对request对象进行认证操作 12def perform_authentication(self, request): request.user perform_authentication方法中调用执行request中的user方法，这里的request是封装了原始request,认证对象列表，处理器列表等之后的request对象 123456789101112class Request(object): ... @property def user(self): """ Returns the user associated with the current request, as authenticated by the authentication classes provided to the request. """ if not hasattr(self, '_user'): with wrap_attributeerrors(): self._authenticate() return self._user 从request中获取_user的值，如果获取到则执行_authenticate方法，否则返回_user 12345678910111213141516def _authenticate(self): &quot;&quot;&quot; Attempt to authenticate the request using each authentication instance in turn. &quot;&quot;&quot; for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return 在这里self.authenticators实际上是get_authenticators方法执行完成后返回的对象列表 1234567891011121314class Request(object): def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): assert isinstance(request, HttpRequest), ( 'The `request` argument must be an instance of ' '`django.http.HttpRequest`, not `&#123;&#125;.&#123;&#125;`.' .format(request.__class__.__module__, request.__class__.__name__) ) self._request = request self.parsers = parsers or () self.authenticators = authenticators or () ... 循环认证的对象列表,执行每一个认证方法的类中的authenticate方法，得到通过认证的用户及用户的口令的元组，并返回元组完成认证的流程 在_authenticate方法中使用了try/except方法来捕获authenticate方法可能出现的异常 如果出现异常,就调用_not_authenticated方法来设置返回元组中的用户及口令并终止程序继续运行 总结，Django restframework的认证流程如下图 Django restframework内置的认证类在上面的项目例子中，在UsersView的get方法中，打印authentication_classes和request._user的值 1234567class UserView(APIView): # authentication_classes = [MyAuthentication,] def get(self,request,*args,**kwargs): print('authentication_classes:', self.authentication_classes) print(request._user) return HttpResponse("UserView GET") 打印结果为 12authentication_classes: [&lt;class 'rest_framework.authentication.SessionAuthentication'&gt;, &lt;class 'rest_framework.authentication.BasicAuthentication'&gt;]AnonymousUser 由此可以知道,authentication_classes默认是Django restframework内置的认证类，而request._user为AnonymousUser,因为发送GET请求，用户没有进行登录认证，所以为匿名用户 在视图函数中导入这两个类,再查看这两个类的源码,可以知道 123456789101112131415161718192021222324class BasicAuthentication(BaseAuthentication): www_authenticate_realm = 'api' def authenticate(self, request): ... def authenticate_credentials(self, userid, password): ...class SessionAuthentication(BaseAuthentication): def authenticate(self, request): ... def enforce_csrf(self, request): ...class TokenAuthentication(BaseAuthentication): ... 从上面的源码可以发现,这个文件中不仅定义了SessionAuthentication和BasicAuthentication这两个类, 相关的类还有TokenAuthentication,而且这三个认证相关的类都是继承自BaseAuthentication类 从上面的源码可以大概知道,这三个继承自BaseAuthentication的类是Django restframework内置的认证方式. 自定义认证功能在上面我们知道,Request会调用认证相关的类及方法,APIView会设置认证相关的类及方法 所以如果想自定义认证功能,只需要重写authenticate方法及authentication_classes的对象列表即可 修改上面的例子的views.py文件 1234567891011121314151617181920212223242526272829from django.shortcuts import render, HttpResponsefrom rest_framework.views import APIViewfrom rest_framework.authentication import BaseAuthenticationfrom rest_framework import exceptionsTOKEN_LIST = [ # 定义token_list 'aabbcc', 'ddeeff',]class UserAuthView(BaseAuthentication): def authenticate(self, request): tk = request._request.GET.get("tk") # request._request为原生的request if tk in TOKEN_LIST: return (tk, None) # 返回一个元组 raise exceptions.AuthenticationFailed("用户认证失败") def authenticate_header(self, request): # 如果不定义authenticate_header方法会抛出异常 passclass UserView(APIView): authentication_classes = [UserAuthView, ] def get(self, request, *args, **kwargs): print(request.user) return HttpResponse("UserView GET") 启动项目,在浏览器中输入http://127.0.0.1:8000/users/?tk=aabbcc,然后回车,在服务端后台会打印 1aabbcc 把浏览器中的url换为http://127.0.0.1:8000/users/?tk=ddeeff,后台打印信息则变为 1ddeeff 这样就实现REST framework的自定义认证功能 Django restframework认证的扩展基于Token进行用户认证修改上面的项目，在urls.py文件中添加一条路由记录 123456789from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^users/',views.UsersView.as_view()), url(r'^auth/',views.AuthView.as_view()),] 修改视图函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from django.shortcuts import render,HttpResponsefrom rest_framework.views import APIViewfrom rest_framework.authentication import BaseAuthenticationfrom rest_framework import exceptionsfrom django.http import JsonResponsedef gen_token(username): """ 利用时间和用户名生成用户token :param username: :return: """ import time import hashlib ctime=str(time.time()) hash=hashlib.md5(username.encode("utf-8")) hash.update(ctime.encode("utf-8")) return hash.hexdigest()class AuthView(APIView): def post(self, request, *args, **kwargs): """ 获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户 :param request: :param args: :param kwargs: :return: """ res = &#123;'code': 1000, 'msg': None&#125; user = request.data.get("user") pwd = request.data.get("pwd") from app01 import models user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first() if user_obj: token = gen_token(user) # 生成用户口令 # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令 models.Token.objects.update_or_create(user=user_obj, defaults=&#123;'token': token&#125;) print("user_token:", token) res['code'] = 1001 res['token'] = token else: res['msg'] = "用户名或密码错误" return JsonResponse(res)class UserAuthView(BaseAuthentication): def authenticate(self,request): tk=request.query_params.GET.get("tk") # 获取请求头中的用户token from app01 import models token_obj=models.Token.objects.filter(token=tk).first() if token_obj: # 用户数据库中已经存在用户口令返回认证元组 return (token_obj.user,token_obj) raise exceptions.AuthenticationFailed("认证失败") def authenticate_header(self,request): passclass UsersView(APIView): authentication_classes = [UserAuthView,] def get(self,request,*args,**kwargs): return HttpResponse(".....") 创建用户数据库的类 12345678910from django.db import modelsclass UserInfo(models.Model): user=models.CharField(max_length=32) pwd=models.CharField(max_length=64) email=models.CharField(max_length=64)class Token(models.Model): user=models.OneToOneField(UserInfo) token=models.CharField(max_length=64) 创建数据库,并添加两条用户记录 再创建一个test_client.py文件,来发送post请求 12345678import requestsresponse=requests.post( url="http://127.0.0.1:8000/auth/", data=&#123;'user':'user1','pwd':'user123'&#125;,)print("response_text:",response.text) 启动Django项目,运行test_client.py文件,则项目的响应信息为 1response_text: &#123;"code": 1001, "msg": null, "token": "eccd2d256f44cb25b58ba602fe7eb42d"&#125; 由此,就完成了自定义的基于token的用户认证 如果想在项目中使用自定义的认证方式时,可以在authentication_classes继承刚才的认证的类即可 1authentication_classes = [UserAuthView,APIViiew]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm快捷键]]></title>
    <url>%2F2019%2F09%2F05%2FPycharm%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[搜索 Ctrl + Shift + F7 用法高亮显示 Ctrl + Alt + F7 显示用法 编辑 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行到后面或下一行 Ctrl + Y 删除当前行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 下一行另起一行 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Alt + I 自动缩进 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 自动导入 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 运行调试 Alt + Shift + F10 运行模式配置 Shift + F10 运行 Shift + F9 调试 Alt + Shift + F9 调试模式配置 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 查找替换 F3 下一个 Ctrl + Shift + F 全局查找 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + R 全局替换 重构 Ctrl + Alt + N 内联 Ctrl + Alt + M 提取方法 F5 复制 F6 剪切 Alt + Delete 安全删除 Shift + F6 方法或变量重命名 Ctrl + Alt + V 提取属性 Ctrl + Alt + F 提取字段 Ctrl + Alt + C 提取常量 Ctrl + Alt + P 提取参数 Ctrl + F6 更改签名 跳转 Ctrl #[0-9] + 跳转到标识的书签 Shift + F11显示书签 Shift + Esc 隐藏当前窗口，焦点到编辑窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 最近访问的文件 Ctrl+Alt+Left/Right 后退、前进 Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从其他窗口回到编辑窗口 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I 查看快速定义 Ctrl + Shift + B 跳转到类型声明 Ctrl + U 跳转到父方法、父类 Alt + Up/Down 跳转到上一个、下一个方法 Ctrl + ]/[ 跳转到代码块结束、开始 Ctrl + F12 弹出文件结构 Ctrl + H 类型层次结构 Ctrl + Shift + H 方法层次结构 Ctrl + Alt + H 调用层次结构 F2 / Shift + F2 下一条、前一条高亮的错误 F4 / Ctrl + Enter 编辑资源、查看资源 Alt + Home 显示导航条F11书签开关 Ctrl + Shift +F11 书签助记开关 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 调试 Alt + F9 运行游标 Alt + F8 验证表达式 F8 跳过 F7 进入 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 Shift + F8 退出 常用 Tab / Shift + Tab 缩进、不缩进当前行（可选中多行） Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl + D 复制选定的区域或行到后面或下一行 Ctrl + Y 删除当前行 Shift + Enter 下一行另起一行 Ctrl +Ｊ 插入模版 Ctrl + Shift +/- 展开/折叠全部代码块 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Shift + F7 将当前单词在整个文件中高亮 Alt + up/down 方法上移或下移动 Alt + Shift + up/down 当前行上移或下移动 Ctrl + B/鼠标左键 转到方法定义处 Ctrl + W 选中增加的代码块 Shift + F6 方法或变量重命名 Ctrl + E 最近访问的文件 Esc 从其他窗口回到编辑窗口 Ctrl + F1 显示错误描述或警告信息 Ctrl + / 行注释（可选中多行）]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2019%2F09%2F05%2FHexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署 两个命令的作用是相同的hexo generate --deployhexo deploy --generate 12hexo deploy -g``hexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub 123hexo new [layout] &lt;title&gt;``hexo new photo &quot;My Gallery&quot;``hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;``hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上123hexo n` #写文章`hexo g` #生成`hexo d` #部署 #可与`hexo g`合并为 `hexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
